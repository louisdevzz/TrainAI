[
    {
        "name":"Load balances from chain",
        "description":"Let's start with a simple example and consider an application where we want to display a user's balances for multiple tokens.",
        "js":"// Load current sender address if it was not loaded yet\r\nif (state.sender == undefined && Ethers.provider()) {\r\n  Ethers.provider()\r\n    .send(\"eth_requestAccounts\", [])\r\n    .then((accounts) => {\r\n      if (accounts.length) {\r\n        // save sender address to the state\r\n        State.update({ sender: accounts[0] });\r\n      }\r\n    });\r\n}\r\n\r\n// Load ERC20 ABI JSON\r\nconst erc20Abi = fetch(\r\n  \"https://ipfs.near.social/ipfs/bafkreifgw34kutqcnusv4yyv7gjscshc5jhrzw7up7pdabsuoxfhlnckrq\"\r\n);\r\nif (!erc20Abi.ok) {\r\n  return \"Loading\";\r\n}\r\n\r\n// Create contract interface\r\nconst iface = new ethers.utils.Interface(erc20Abi.body);\r\n\r\n// specify list of tokens\r\nconst tokens = [\r\n  \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\", // WBTC\r\n  \"0x6b175474e89094c44da98b954eedeac495271d0f\", // DAI\r\n  \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\", // UNI\r\n];\r\n\r\n// load receiver's balance for a giver token\r\nconst getTokenBalance = (receiver, tokenId) => {\r\n  // encode `balanceOf` request\r\n  const encodedData = iface.encodeFunctionData(\"balanceOf\", [receiver]);\r\n\r\n  // send request to the network\r\n  return Ethers.provider()\r\n    .call({\r\n      to: tokenId,\r\n      data: encodedData,\r\n    })\r\n    .then((rawBalance) => {\r\n      // decode response\r\n      const receiverBalanceHex = iface.decodeFunctionResult(\r\n        \"balanceOf\",\r\n        rawBalance\r\n      );\r\n\r\n      return Big(receiverBalanceHex).toFixed(0);\r\n    });\r\n};\r\n\r\nconst loadTokensData = () => {\r\n  // load balances of all tokens\r\n  tokens.map((tokenId) => {\r\n    getTokenBalance(state.sender, tokenId).then((value) => {\r\n      // save balance of every token to the state\r\n      State.update({ [tokenId]: { balance: value, ...state[tokenId] } });\r\n    });\r\n  });\r\n};\r\n\r\nconst renderToken = (tokenId) => (\r\n  <li>\r\n    {tokenId}: {state[tokenId].balance}\r\n  </li>\r\n);\r\n\r\nif (state.sender) {\r\n  loadTokensData();\r\n\r\n  return (\r\n    <>\r\n      <ul>{tokens.map((tokenId) => renderToken(tokenId))}</ul>\r\n      <p>Your account: {state.sender} </p>\r\n    </>\r\n  );\r\n} else {\r\n  // output connect button for anon user\r\n  return <Web3Connect />;\r\n}"
    },
    {
        "name":"Load static data",
        "description":"To format the list, we must determine the decimal precision for each asset. While it's possible to retrieve this information from the ERC-20 contract for each token, it's important to note that the ERC-20 contract lacks certain valuable data such as the token icon and description. As a solution, we can leverage the CoinGecko API to retrieve token details, including the current market price.\r\n\r\nLet's add a function to load token data for a given token from the Coingecko:\r\n\r\n",
        "js":{
            "loadCoingeck":"const loadCoingeckData = (tokenId) => {\r\n    let dataUrl = `https://api.coingecko.com/api/v3/coins/ethereum/contract/${tokenId}`;\r\n\r\n    const data = fetch(dataUrl);\r\n    if (data.ok) {\r\n        return {\r\n            name: data.body.name,\r\n            icon: data.body.image.small,\r\n            decimals: data.body.detail_platforms[\"ethereum\"].decimal_place,\r\n            price: Number(data.body.market_data.current_price.usd),\r\n        };\r\n    }\r\n};",
            "loadTokenData":"const loadTokensData = () => {\r\n  // load balances of all tokens\r\n  tokens.map((tokenId) => {\r\n    getTokenBalance(state.sender, tokenId).then((value) => {\r\n      // save balance of every token to the state\r\n      State.update({ [tokenId]: { balance: value, ...state[tokenId] } });\r\n    });\r\n  });\r\n\r\n  tokens.map((tokenId) => {\r\n    const tokenData = loadCoingeckData(tokenId);\r\n    // save balance of every token to the state\r\n    State.update({ [tokenId]: { ...tokenData, ...state[tokenId] } });\r\n  });\r\n};",
            "renderToken":"const renderToken = (tokenId) => {\r\n  const tokenBalance = Big(state[tokenId].balance ?? 0)\r\n    .div(new Big(10).pow(state[tokenId].decimals ?? 1))\r\n    .toFixed(4);\r\n  const tokenBalanceUSD = (tokenBalance * state[tokenId].price).toFixed(2);\r\n  return (\r\n    <li>\r\n      {state[tokenId].name}: {tokenBalance}{\" \"}\r\n      <img src={state[tokenId].icon} width=\"16\" alt={state[tokenId].symbol} />\r\n      {`(${tokenBalanceUSD} USD)`}\r\n    </li>\r\n  );\r\n};"
        }
    },
    {
        "name":"Save data in social-db",
        "description":"Now, instead of hardcoding the list of tokens directly within the application code, let's transition them to an onchain data repository named social-db. This approach allows us to adjust the list of trackable tokens without having to modify the application's code. It also offers users the flexibility to select from pre-existing token lists or formulate their own.\r\n\r\nLearn more about how key-value storage social-db works.\r\n\r\nHere is an example of a simple application for setting tokens list in social-db.\r\n\r\nIn this format, the data from the example will be stored in social-db.\r\n\r\n{\r\n\"0x6b175474e89094c44da98b954eedeac495271d0f\": \"\",\r\n\"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\": \"\",\r\n\"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\": \"\"\r\n}\r\nViewing this data from the blockchain is accessible for every NEAR app or, for example, through an Explorer app.",
        "js":"// set list of tokens\r\nif (!state.tokensLoaded) {\r\n    // load tokens list from the Social DB\r\n    const tokens = Social.get(`zavodil.near/tokens-db/*`, \"final\");\r\n\r\n    if (tokens) {\r\n        State.update({\r\n            tokensLoaded: true,\r\n            tokens,\r\n        });\r\n    }\r\n}\r\n\r\nconst tokens = Object.keys(state.tokens ?? {});"
    },
    {
        "name":"Caching Data Through GitHub Actions",
        "description":"Ethereum-based applications frequently depend on static content sources to present details about tokens or contracts. Often, frontends pull this data from platforms like CoinGecko or CoinMarketCap, leveraging API keys to enhance the data retrieval rate limit. Without these API keys, and given a significant volume of data, fetching from these platforms can be sluggish or even disrupted. We'll showcase a serverless approach utilizing GitHub Actions. This method preserves the decentralized nature of NEAR gateways (where securely storing API keys isn't feasible), all while ensuring user ease-of-use and swift data loading.\r\n\r\nLet's create a Node.js application that will iterate through a list of tokens from social-db and display the retrieved data along with a timestamp of the operation.",
        "js":{
            "application":"import * as nearAPI from \"near-api-js\";\r\nimport * as cg from \"coingecko-api-v3\";\r\n\r\nconst CONTRACT_ID = \"social.near\";\r\nconst ETHEREUM_NETWORK_ID = \"ethereum\";\r\nconst FETCH_TIMEOUT = 7000;\r\n\r\nasync function connect() {\r\n    const config = {\r\n        networkId: \"mainnet\",\r\n        keyStore: new nearAPI.keyStores.InMemoryKeyStore(),\r\n        nodeUrl: \"https://rpc.mainnet.near.org\",\r\n        walletUrl: \"https://wallet.mainnet.near.org\",\r\n        helperUrl: \"https://helper.mainnet.near.org\",\r\n        explorerUrl: \"https://nearblocks.io\",\r\n    };\r\n    const near = await nearAPI.connect(config);\r\n    const account = await near.account(CONTRACT_ID);\r\n\r\n    const contract = new nearAPI.Contract(\r\n        account, // the account object that is connecting\r\n        CONTRACT_ID, // name of contract you're connecting to\r\n        {\r\n            viewMethods: [\"get\"], // view methods do not change state but usually return a value\r\n            changeMethods: [], // change methods modify state\r\n            sender: account, // account object to initialize and sign transactions.\r\n        }\r\n    );\r\n\r\n    return contract;\r\n}\r\n\r\n// load data from the social-db\r\nconst contract = await connect();\r\nconst data = await contract.get({ keys: [\"zavodil.near/tokens-db/*\"] });\r\nconst tokens = data[\"zavodil.near\"][\"tokens-db\"];\r\n\r\n// init coingecko client\r\nconst client = new cg.CoinGeckoClient({\r\n    timeout: 5000,\r\n    autoRetry: false,\r\n});\r\n\r\nlet res = {};\r\nfor (let i = 0; i < Object.keys(tokens).length; i++) {\r\n    const tokenId = Object.keys(tokens)[i];\r\n\r\n    try {\r\n        // load data from coingecko\r\n        const data = await client.contract({\r\n            id: ETHEREUM_NETWORK_ID,\r\n            contract_address: tokenId,\r\n        });\r\n        // format output\r\n        const tokenData = {\r\n            name: data[\"name\"],\r\n            symbol: data[\"symbol\"],\r\n            icon: data[\"image\"]?.[\"thumb\"],\r\n            decimals: data[\"detail_platforms\"]?.[ETHEREUM_NETWORK_ID]?.[\"decimal_place\"],\r\n            price: data[\"market_data\"]?.[\"current_price\"]?.[\"usd\"],\r\n        };\r\n        // store output\r\n        res[tokenId] = tokenData;\r\n\r\n        // add timeout to avoid rate limits\r\n        await new Promise((resolve) => {\r\n            setTimeout(resolve, FETCH_TIMEOUT);\r\n        });\r\n    } catch (ex) {\r\n        console.error(tokenId, ex)\r\n    }\r\n}\r\n\r\n// output results\r\nconsole.log(\r\n    JSON.stringify({\r\n        timestamp: Date.now(),\r\n        data: res,\r\n    })\r\n);\r\n",
            "githubWoker":"name: Tokens Data Updater\r\non:\r\n  workflow_dispatch:\r\n  schedule:\r\n    - cron:  '*/15 * * * *'\r\n\r\njobs:\r\n  updateStats:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - name: Prepare        \r\n        uses: actions/setup-node@v3\r\n        with:\r\n            node-version: 16\r\n      - run: npm i      \r\n      - name: Tokens Data\r\n        run: node load > tokens-db.json              \r\n        env:\r\n          EXPORT_MODE: CS\r\n      - uses: EndBug/add-and-commit@v9 \r\n        with: \r\n          author_name: \"Tokens Data Updater\"\r\n          add: 'tokens-db.json --force'\r\n          message: \"Tokens Data fetching\"",
            "loadTokenData":"const loadTokensData = () => {\r\n    let cacheTokenData = {};\r\n    // load data generated by github action\r\n    const cachedData = fetch(\r\n        `https://raw.githubusercontent.com/zavodil/tokens-db/main/tokens-db.json`\r\n    );\r\n    if (cachedData.ok) {\r\n        const cache = JSON.parse(cachedData.body);\r\n        const cacheDate = new Date(cache.timestamp);\r\n        const timeDifference = Date.now() - cacheDate.getTime();\r\n        if (timeDifference <= 30 * 60 * 1000) {  // use cached data if it is not outdated (30 min)\r\n            cacheTokenData = cache.data;\r\n        }\r\n\r\n        tokens.map((tokenId) => {\r\n            const tokenData = cacheTokenData.hasOwnProperty(tokenId)\r\n                ? cacheTokenData?.[tokenId]\r\n                : // load data from coingecko if we don't have cached data only\r\n                loadCoingeckData(tokenId);\r\n            // save balance of every token to the state\r\n            State.update({ [tokenId]: { ...tokenData, ...state[tokenId] } });\r\n        });\r\n    }\r\n};\r\n"
        }
    }
]